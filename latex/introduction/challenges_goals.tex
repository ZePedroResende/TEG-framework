
\section{Challenges \& Goals}


\subsection{ Definir com detalhe o objetivo da dissertacao}
The main goal of this work is to add new functionalities in the current HEP-Frame version, namely to integrate support in this framework for specification and execution of conditional pipelines using conditional task graphs. This allows HEP-Frame to support a broader range of pipelined applications while employing the existing optimization strategies for conventional task graphs, as well as implement new scheduling strategies for task pipelines that require conditional paths of execution.
Most task schedulers use conventional execution graphs, where the nodes represent tasks and the directed connections among them represent possible execution flows between tasks. Conditional task graphs may not be possible to express as a traditional execution graph. A single graph representation must include (i) dependencies among tasks, (ii) conditional paths of execution, and (iii) the filtering out of elements, preventing them from being executed by the remaining tasks. An adequate graph representation must be designed, as it is critical to develop efficient strategies to schedule these tasks among workers.
One common optimisation strategy used at the hardware level to improve the performance of conditional branches is branch prediction. It was already identified in a preliminary analysis of the problem that branch prediction may be a vital component of the task scheduling strategy, as it allows subsequent tasks to be processed simultaneously with a current task without knowing its result yet. This should be considered when defining the graph to ensure that, through the analysis of this graph, every code execution with task dependencies, conditional paths, and branch prediction provides the correct results.

\subsubsection{Definir uma estrutura em codigo para um utilizador criar tarefas e definir a sua pipeline}
To provide a easy to use and pleasant interface for the user we are using a pre-processor based approach where the user defines the tasks with return statements with the name of the tasks on a return statement in each conditional step. The pre-processor then takes all these statements, builds a graph that defines the control flow of the pipeline. With all the possible paths we can create a header file with an Enum that defines the integer equivalent to each task so that our program can be compiled. With this, we don't have to create a domain-specific language, and we can structure our code like a typical program. This method is incredibly flexible because it allows introducing more validation before compilation, like for example the graph validation that we are going to talk about new.

\subsubsection{Criar um escalonador com base em trabalho existente pra gerir execucao paralela das tarefas destas pipelines}
Although there is little work in conditional graph tasks and conditional pipelines scheduling we can take our knowledge in graph scheduler and list schedulers to start the development and modulation of an effective scheduler model for this type of problem. With this, we also have some usage examples of this type of structure in other domains that can be helpful to understand common issues and how structuring and the representation at the computational level are done in a relatively compact and efficient way.
This scheduler must allow executing these tasks with high levels of parallelism and data discarding that the current HEP-Frame schedule allows.
Latter, the use of branch prediction and speculative execution, may be considered as an option being an optimisation used in conditional branching at the hardware level.

\subsubsection{Garantir a correcao da pipeline}
With the use of the pre-processor and the graph generated at compilation time that we discussed before, we can make some validations to the graph for any cycles that may create deadlocks of infinite loops. This type of validation can be done using Depth First Search, Tarjan's strongly connected components algorithm or Topological sorting (if we want that our graphs are acyclic, once that only DAGs can be topological sorted).
Also, to guaranty the validity of the multiple Boolean conditional formulas, that will control all of the flow of the program, we are going to use the Boolean satisfiability problem solver also known as SAT solver. This type of plan allows us to input a reduced Boolean formula that the user submitted as a condition and tell us if that formula can determining if an interpretation that satisfies a given Boolean equation exists, that is if at any point this formula can be true.

\subsubsection{Validar com casos de estudo (necessario escolher casos sinteticos e reais na fisica de particulas}

An illustrative case study needs to be implemented to assess the performance and correctness of the scheduling of conditional task graphs in HEP-Frame. Once stable, the scheduler should be tested with a real case study, such as a particle physics scientific data analysis, since this type of applications may use conditional tasks in their pipelines. 
\subsubsection{Integrar na HEP-Frame e objetivo dessa integracao}

The developed scheduler should be accompanied by other tools to automatically parse a predefined signature of a task and identify its dependencies, identify data dependencies, validate the created graph, and measure several metrics useful for the scheduler. These tools should be efficient to either operate at compile- or run-time, depending on their purpose. Once validated in a contained code base, the scheduler and these tools should be integrated into HEP-Frame.
\subsubsection{Uma lista de tarefas a realizar que sao basicamente os pontos anteriores mas resumidos}
In the end, we should end up with the following components:
\begin{itemize}
    \item Preprocessor
    \item Graph Creator
    \item Graph validator
    \item Conditional Validator
    \item Scheduler
\end{itemize}
